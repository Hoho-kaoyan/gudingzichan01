# 内网迁移指南（详细版）

本文档提供将固定资产管理系统从SQLite迁移到Oracle或SQL Server的详细步骤指南。

## 目录

1. [迁移概述](#迁移概述)
2. [准备工作](#准备工作)
3. [步骤一：环境准备](#步骤一环境准备)
4. [步骤二：代码配置化改造](#步骤二代码配置化改造)
5. [步骤三：数据库准备](#步骤三数据库准备)
6. [步骤四：数据迁移](#步骤四数据迁移)
7. [步骤五：测试验证](#步骤五测试验证)
8. [步骤六：上线部署](#步骤六上线部署)
9. [常见问题排查](#常见问题排查)

---

## 迁移概述

### 当前状态
- **数据库**：SQLite（文件数据库：`backend/assets.db`）
- **连接方式**：直接文件连接
- **ORM**：SQLAlchemy 2.0+

### 目标状态
- **数据库**：Oracle 或 SQL Server（企业级数据库）
- **连接方式**：网络连接（需要连接字符串）
- **配置方式**：通过环境变量或配置文件

### 迁移工作量评估
- **配置化改造**：1-2小时
- **数据库准备**：1-2小时
- **数据迁移**：2-4小时（取决于数据量）
- **测试验证**：4-8小时
- **总计**：1-2个工作日

---

## 准备工作

### 1. 备份当前数据

**步骤1.1：备份SQLite数据库**

```bash
# Windows PowerShell
cd backend
Copy-Item assets.db assets_backup_$(Get-Date -Format 'yyyyMMdd_HHmmss').db

# Linux/Mac
cd backend
cp assets.db assets_backup_$(date +%Y%m%d_%H%M%S).db
```

**步骤1.2：验证备份文件**

```bash
# 检查文件大小
# Windows
Get-Item assets_backup_*.db | Select-Object Name, Length

# Linux/Mac
ls -lh assets_backup_*.db
```

**步骤1.3：导出数据为SQL（可选，作为额外备份）**

```bash
# 使用sqlite3命令行工具
sqlite3 assets.db .dump > assets_backup.sql
```

### 2. 确认目标数据库信息

**需要收集的信息**：

#### Oracle数据库
- [ ] 数据库服务器IP地址
- [ ] 端口号（默认1521）
- [ ] Service Name 或 SID
- [ ] 数据库用户名
- [ ] 数据库密码
- [ ] 字符集（建议UTF-8）

#### SQL Server数据库
- [ ] 数据库服务器IP地址
- [ ] 端口号（默认1433）
- [ ] 数据库名称
- [ ] 认证方式（SQL认证/Windows认证）
- [ ] 数据库用户名（如果使用SQL认证）
- [ ] 数据库密码（如果使用SQL认证）
- [ ] ODBC驱动版本

### 3. 准备开发环境

**步骤3.1：确认Python版本**

```bash
python --version
# 需要Python 3.8+
```

**步骤3.2：确认当前依赖**

```bash
cd backend
pip list | findstr -i "sqlalchemy fastapi"
# 或 Linux/Mac
pip list | grep -i "sqlalchemy\|fastapi"
```

---

## 步骤一：环境准备

### 1.1 安装数据库驱动

#### Oracle驱动安装

**方式A：使用cx_Oracle（需要Oracle客户端）**

```bash
# 安装Python包
pip install cx_Oracle

# Windows：下载并安装Oracle Instant Client
# 1. 访问Oracle官网下载Instant Client
# 2. 解压到目录，如 C:\oracle\instantclient_21_8
# 3. 将目录添加到系统PATH环境变量
# 4. 或设置环境变量：
#    set ORACLE_HOME=C:\oracle\instantclient_21_8
#    set PATH=%ORACLE_HOME%;%PATH%

# Linux：安装Oracle Instant Client
# CentOS/RHEL:
sudo yum install oracle-instantclient-basic oracle-instantclient-devel
# Ubuntu/Debian:
# 下载.deb包并安装
sudo dpkg -i oracle-instantclient-basic_*.deb
sudo dpkg -i oracle-instantclient-devel_*.deb
```

**方式B：使用oracledb（纯Python，推荐，无需客户端）**

```bash
pip install oracledb
```

**验证安装**：

```bash
python -c "import cx_Oracle; print('cx_Oracle安装成功')"
# 或
python -c "import oracledb; print('oracledb安装成功')"
```

#### SQL Server驱动安装

**步骤1：安装pyodbc**

```bash
pip install pyodbc
```

**步骤2：安装ODBC驱动**

**Windows**：
```bash
# 通常已预装，如果没有：
# 1. 访问Microsoft官网下载"ODBC Driver 17 for SQL Server"
# 2. 或使用"ODBC Driver 18 for SQL Server"（更新版本）
# 3. 安装后验证：
odbcinst -q -d
# 应该能看到 "ODBC Driver 17 for SQL Server" 或类似条目
```

**Linux**：
```bash
# Ubuntu/Debian
curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -
curl https://packages.microsoft.com/config/ubuntu/20.04/prod.list | sudo tee /etc/apt/sources.list.d/mssql-release.list
sudo apt-get update
sudo ACCEPT_EULA=Y apt-get install -y msodbcsql17

# CentOS/RHEL
sudo curl https://packages.microsoft.com/config/rhel/8/prod.repo > /etc/yum.repos.d/mssql-release.repo
sudo ACCEPT_EULA=Y yum install -y msodbcsql17
```

**验证安装**：

```bash
python -c "import pyodbc; print('pyodbc安装成功')"
```

### 1.2 安装python-dotenv（用于.env文件）

```bash
pip install python-dotenv
```

### 1.3 更新requirements.txt

在 `backend/requirements.txt` 中添加：

```txt
# 现有依赖...
fastapi>=0.104.0
uvicorn[standard]>=0.24.0
sqlalchemy>=2.0.0
python-jose[cryptography]>=3.3.0
bcrypt>=4.0.0
pandas>=2.0.0
openpyxl>=3.1.0
python-multipart>=0.0.6

# 数据库驱动（根据目标数据库选择）
# Oracle（二选一）
cx_Oracle>=8.3.0
# 或
# oracledb>=1.4.0

# SQL Server
pyodbc>=5.0.0

# 环境变量支持
python-dotenv>=1.0.0
```

---

## 步骤二：代码配置化改造

### 2.1 创建新的database.py配置

**步骤2.1.1：备份原文件**

```bash
cd backend
# Windows
Copy-Item database.py database.py.backup

# Linux/Mac
cp database.py database.py.backup
```

**步骤2.1.2：创建新的database.py**

将 `backend/database.py` 替换为以下内容：

```python
"""
数据库配置和会话管理
支持SQLite、Oracle、SQL Server
通过环境变量DB_TYPE切换数据库类型
"""
import os
from pathlib import Path
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv

# 加载.env文件（如果存在）
load_dotenv()

# 获取数据库类型（从环境变量读取，默认为sqlite）
DB_TYPE = os.getenv("DB_TYPE", "sqlite").lower()

# 创建基础模型类
Base = declarative_base()

# 根据数据库类型创建引擎
if DB_TYPE == "sqlite":
    # SQLite配置（默认，保持向后兼容）
    BASE_DIR = Path(__file__).resolve().parent
    DATABASE_PATH = BASE_DIR / "assets.db"
    SQLALCHEMY_DATABASE_URL = f"sqlite:///{DATABASE_PATH}"
    
    engine = create_engine(
        SQLALCHEMY_DATABASE_URL,
        connect_args={"check_same_thread": False}  # SQLite需要这个参数
    )
    
elif DB_TYPE == "oracle":
    # Oracle配置
    DB_USER = os.getenv("DB_USER")
    DB_PASSWORD = os.getenv("DB_PASSWORD")
    DB_HOST = os.getenv("DB_HOST", "localhost")
    DB_PORT = os.getenv("DB_PORT", "1521")
    DB_SERVICE_NAME = os.getenv("DB_SERVICE_NAME")
    DB_SID = os.getenv("DB_SID")  # 如果使用SID而不是Service Name
    
    if not DB_USER or not DB_PASSWORD:
        raise ValueError("Oracle数据库需要设置DB_USER和DB_PASSWORD环境变量")
    
    # 构建连接字符串
    if DB_SERVICE_NAME:
        # 使用Service Name（推荐）
        SQLALCHEMY_DATABASE_URL = (
            f"oracle+cx_oracle://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/"
            f"?service_name={DB_SERVICE_NAME}"
        )
    elif DB_SID:
        # 使用SID
        SQLALCHEMY_DATABASE_URL = (
            f"oracle+cx_oracle://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_SID}"
        )
    else:
        raise ValueError("Oracle数据库需要设置DB_SERVICE_NAME或DB_SID环境变量")
    
    # Oracle连接参数
    connect_args = {
        "encoding": "UTF-8",
        "nencoding": "UTF-8"
    }
    
    # 连接池配置
    pool_size = int(os.getenv("DB_POOL_SIZE", "5"))
    max_overflow = int(os.getenv("DB_MAX_OVERFLOW", "10"))
    
    engine = create_engine(
        SQLALCHEMY_DATABASE_URL,
        connect_args=connect_args,
        pool_pre_ping=True,  # 连接池预检查，自动重连
        pool_size=pool_size,
        max_overflow=max_overflow,
        echo=False  # 设置为True可以打印SQL语句（调试用）
    )
    
elif DB_TYPE == "sqlserver" or DB_TYPE == "mssql":
    # SQL Server配置
    DB_USER = os.getenv("DB_USER")
    DB_PASSWORD = os.getenv("DB_PASSWORD")
    DB_HOST = os.getenv("DB_HOST", "localhost")
    DB_PORT = os.getenv("DB_PORT", "1433")
    DB_NAME = os.getenv("DB_NAME", "asset_management")
    DB_DRIVER = os.getenv("DB_DRIVER", "ODBC Driver 17 for SQL Server")
    
    if not DB_USER or not DB_PASSWORD:
        raise ValueError("SQL Server数据库需要设置DB_USER和DB_PASSWORD环境变量")
    
    # URL编码特殊字符
    from urllib.parse import quote_plus
    
    # 构建连接字符串
    SQLALCHEMY_DATABASE_URL = (
        f"mssql+pyodbc://{quote_plus(DB_USER)}:{quote_plus(DB_PASSWORD)}"
        f"@{DB_HOST}:{DB_PORT}/{DB_NAME}?"
        f"driver={quote_plus(DB_DRIVER)}&"
        f"TrustServerCertificate=yes"  # 如果使用自签名证书
    )
    
    # 连接池配置
    pool_size = int(os.getenv("DB_POOL_SIZE", "5"))
    max_overflow = int(os.getenv("DB_MAX_OVERFLOW", "10"))
    
    engine = create_engine(
        SQLALCHEMY_DATABASE_URL,
        pool_pre_ping=True,
        pool_size=pool_size,
        max_overflow=max_overflow,
        echo=False
    )
    
else:
    raise ValueError(f"不支持的数据库类型: {DB_TYPE}。支持的类型: sqlite, oracle, sqlserver")

# 创建会话工厂
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# 依赖注入：获取数据库会话
def get_db():
    """
    获取数据库会话
    使用FastAPI的依赖注入系统
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

**步骤2.1.3：验证修改**

```bash
# 测试导入是否正常
python -c "from database import engine, Base, get_db; print('导入成功')"
```

### 2.2 创建.env文件模板

**步骤2.2.1：创建.env.example文件**

在 `backend/` 目录下创建 `.env.example` 文件：

```env
# ============================================
# 数据库类型配置
# ============================================
# 可选值：sqlite, oracle, sqlserver
# 默认：sqlite（开发环境）
DB_TYPE=sqlite

# ============================================
# Oracle数据库配置
# ============================================
# 当DB_TYPE=oracle时，需要配置以下参数：
# DB_USER=asset_user
# DB_PASSWORD=your_secure_password
# DB_HOST=192.168.1.100
# DB_PORT=1521
# DB_SERVICE_NAME=ORCL
# # 或者使用SID（二选一）
# # DB_SID=ORCL

# ============================================
# SQL Server数据库配置
# ============================================
# 当DB_TYPE=sqlserver时，需要配置以下参数：
# DB_USER=sa
# DB_PASSWORD=your_secure_password
# DB_HOST=192.168.1.100
# DB_PORT=1433
# DB_NAME=asset_management
# DB_DRIVER=ODBC Driver 17 for SQL Server

# ============================================
# 连接池配置（可选）
# ============================================
# DB_POOL_SIZE=5
# DB_MAX_OVERFLOW=10
```

**步骤2.2.2：创建实际的.env文件**

```bash
# 复制模板
# Windows
Copy-Item .env.example .env

# Linux/Mac
cp .env.example .env
```

然后编辑 `.env` 文件，填入实际的数据库连接信息。

### 2.3 测试配置是否生效

**步骤2.3.1：创建测试脚本**

创建 `backend/test_db_config.py`：

```python
"""
测试数据库配置是否正确
"""
import os
from dotenv import load_dotenv

# 加载环境变量
load_dotenv()

print("=" * 50)
print("数据库配置测试")
print("=" * 50)

DB_TYPE = os.getenv("DB_TYPE", "sqlite")
print(f"数据库类型: {DB_TYPE}")

if DB_TYPE == "oracle":
    print(f"  DB_USER: {os.getenv('DB_USER', '未设置')}")
    print(f"  DB_HOST: {os.getenv('DB_HOST', '未设置')}")
    print(f"  DB_PORT: {os.getenv('DB_PORT', '未设置')}")
    print(f"  DB_SERVICE_NAME: {os.getenv('DB_SERVICE_NAME', '未设置')}")
    print(f"  DB_SID: {os.getenv('DB_SID', '未设置')}")
    
elif DB_TYPE == "sqlserver":
    print(f"  DB_USER: {os.getenv('DB_USER', '未设置')}")
    print(f"  DB_HOST: {os.getenv('DB_HOST', '未设置')}")
    print(f"  DB_PORT: {os.getenv('DB_PORT', '未设置')}")
    print(f"  DB_NAME: {os.getenv('DB_NAME', '未设置')}")
    print(f"  DB_DRIVER: {os.getenv('DB_DRIVER', '未设置')}")

print("=" * 50)

# 测试导入database模块
try:
    from database import engine, Base, get_db
    print("✅ database模块导入成功")
    
    # 测试连接
    with engine.connect() as conn:
        result = conn.execute("SELECT 1")
        print("✅ 数据库连接成功")
        
except Exception as e:
    print(f"❌ 错误: {e}")
    import traceback
    traceback.print_exc()
```

**步骤2.3.2：运行测试**

```bash
# 先测试SQLite（默认）
python test_db_config.py

# 然后测试目标数据库（设置环境变量后）
# Windows PowerShell
$env:DB_TYPE="oracle"
$env:DB_USER="asset_user"
# ... 设置其他环境变量
python test_db_config.py
```

---

## 步骤三：数据库准备

### 3.1 Oracle数据库准备

#### 步骤3.1.1：连接到Oracle数据库

使用SQL*Plus或其他Oracle客户端工具连接：

```bash
# 使用SQL*Plus
sqlplus sys/password@host:port/service_name as sysdba
```

#### 步骤3.1.2：创建表空间（可选，如果DBA要求）

```sql
-- 创建表空间
CREATE TABLESPACE asset_ts
DATAFILE '/u01/app/oracle/oradata/ORCL/asset_ts.dbf' SIZE 100M
AUTOEXTEND ON NEXT 10M MAXSIZE UNLIMITED;

-- 注意：路径需要根据实际环境修改
```

#### 步骤3.1.3：创建数据库用户

```sql
-- 创建用户（如果使用表空间）
CREATE USER asset_user IDENTIFIED BY your_secure_password
DEFAULT TABLESPACE asset_ts
TEMPORARY TABLESPACE temp
QUOTA UNLIMITED ON asset_ts;

-- 或者不使用表空间（使用默认表空间）
CREATE USER asset_user IDENTIFIED BY your_secure_password;

-- 授予权限
GRANT CONNECT, RESOURCE TO asset_user;
GRANT CREATE SESSION TO asset_user;
GRANT CREATE TABLE TO asset_user;
GRANT CREATE SEQUENCE TO asset_user;
GRANT UNLIMITED TABLESPACE TO asset_user;

-- 如果需要创建视图
GRANT CREATE VIEW TO asset_user;

-- 提交
COMMIT;
```

#### 步骤3.1.4：验证用户创建成功

```sql
-- 切换到新用户
CONNECT asset_user/your_secure_password@host:port/service_name

-- 测试创建表权限
CREATE TABLE test_table (id NUMBER PRIMARY KEY);
DROP TABLE test_table;

-- 如果成功，说明权限配置正确
```

#### 步骤3.1.5：检查字符集

```sql
-- 检查数据库字符集
SELECT * FROM NLS_DATABASE_PARAMETERS WHERE PARAMETER = 'NLS_CHARACTERSET';

-- 应该显示 AL32UTF8 或 UTF8（支持中文）
-- 如果不是，需要联系DBA修改
```

### 3.2 SQL Server数据库准备

#### 步骤3.2.1：连接到SQL Server

使用SQL Server Management Studio (SSMS) 或 sqlcmd：

```bash
# 使用sqlcmd
sqlcmd -S host,port -U sa -P password
```

#### 步骤3.2.2：创建数据库

```sql
-- 创建数据库（使用中文排序规则）
CREATE DATABASE asset_management
COLLATE Chinese_PRC_CI_AS;

-- 使用数据库
USE asset_management;
GO
```

#### 步骤3.2.3：创建登录用户

```sql
-- 创建登录用户（在master数据库中执行）
USE master;
GO

CREATE LOGIN asset_user WITH PASSWORD = 'your_secure_password';
GO

-- 使用应用数据库
USE asset_management;
GO

-- 创建数据库用户
CREATE USER asset_user FOR LOGIN asset_user;
GO

-- 授予权限（方式1：授予db_owner角色，拥有所有权限）
ALTER ROLE db_owner ADD MEMBER asset_user;
GO

-- 或者（方式2：授予最小必要权限）
-- GRANT SELECT, INSERT, UPDATE, DELETE ON SCHEMA::dbo TO asset_user;
-- GRANT CREATE TABLE TO asset_user;
-- GRANT ALTER ON SCHEMA::dbo TO asset_user;
GO
```

#### 步骤3.2.4：验证用户创建成功

```sql
-- 测试连接
-- 使用sqlcmd以新用户身份连接
sqlcmd -S host,port -U asset_user -P your_secure_password -d asset_management

-- 在SQL Server中测试
USE asset_management;
GO

-- 测试创建表权限
CREATE TABLE test_table (id INT PRIMARY KEY);
DROP TABLE test_table;
GO

-- 如果成功，说明权限配置正确
```

#### 步骤3.2.5：检查排序规则

```sql
-- 检查数据库排序规则
SELECT DATABASEPROPERTYEX('asset_management', 'Collation') AS Collation;

-- 应该显示包含 Chinese_PRC 或 SQL_Latin1 的排序规则
```

### 3.3 测试数据库连接

#### 步骤3.3.1：创建连接测试脚本

创建 `backend/test_connection.py`：

```python
"""
测试数据库连接
"""
import os
from dotenv import load_dotenv
from sqlalchemy import create_engine, text

# 加载环境变量
load_dotenv()

DB_TYPE = os.getenv("DB_TYPE", "sqlite")

print(f"测试 {DB_TYPE.upper()} 数据库连接...")
print("=" * 50)

try:
    # 导入database模块（会使用.env中的配置）
    from database import engine
    
    # 测试连接
    with engine.connect() as conn:
        # 执行简单查询
        if DB_TYPE == "sqlite":
            result = conn.execute(text("SELECT 1"))
        elif DB_TYPE == "oracle":
            result = conn.execute(text("SELECT 1 FROM DUAL"))
        elif DB_TYPE == "sqlserver":
            result = conn.execute(text("SELECT 1"))
        
        row = result.fetchone()
        print(f"✅ 连接成功！查询结果: {row[0]}")
        
        # 测试数据库版本
        if DB_TYPE == "oracle":
            result = conn.execute(text("SELECT * FROM V$VERSION"))
            version = result.fetchone()
            print(f"✅ Oracle版本: {version[0] if version else '未知'}")
        elif DB_TYPE == "sqlserver":
            result = conn.execute(text("SELECT @@VERSION"))
            version = result.fetchone()
            print(f"✅ SQL Server版本: {version[0][:50] if version else '未知'}...")
        
except Exception as e:
    print(f"❌ 连接失败: {e}")
    import traceback
    traceback.print_exc()
    print("\n请检查：")
    print("1. 数据库服务是否启动")
    print("2. 网络连接是否正常")
    print("3. 用户名和密码是否正确")
    print("4. 防火墙是否允许连接")
    print("5. 环境变量配置是否正确")
```

#### 步骤3.3.2：运行连接测试

```bash
# 确保.env文件已配置
python test_connection.py
```

**预期输出**：
```
测试 ORACLE 数据库连接...
==================================================
✅ 连接成功！查询结果: 1
✅ Oracle版本: Oracle Database 19c Enterprise Edition Release 19.0.0.0.0
```

---

## 步骤四：数据迁移

### 4.1 在新数据库创建表结构

#### 步骤4.1.1：创建表结构脚本

创建 `backend/create_tables.py`：

```python
"""
在新数据库中创建表结构
"""
import os
from dotenv import load_dotenv

# 加载环境变量
load_dotenv()

# 确保使用目标数据库
DB_TYPE = os.getenv("DB_TYPE", "sqlite")
if DB_TYPE == "sqlite":
    print("警告：当前配置为SQLite，请先设置DB_TYPE环境变量")
    exit(1)

print(f"在 {DB_TYPE.upper()} 数据库中创建表结构...")
print("=" * 50)

try:
    from database import engine, Base
    # 导入所有模型（确保所有表都被创建）
    from models import (
        User, AssetCategory, Asset, TransferRequest, ReturnRequest,
        AssetEditRequest, AssetHistory, SafetyCheckType, SafetyCheckTask,
        TaskAsset, SafetyCheckHistory
    )
    
    # 创建所有表
    print("正在创建表结构...")
    Base.metadata.create_all(bind=engine)
    print("✅ 表结构创建成功！")
    
    # 列出创建的表
    print("\n已创建的表：")
    for table_name in Base.metadata.tables.keys():
        print(f"  - {table_name}")
    
except Exception as e:
    print(f"❌ 创建表结构失败: {e}")
    import traceback
    traceback.print_exc()
```

#### 步骤4.1.2：执行表结构创建

```bash
# 确保.env文件配置为目标数据库
python create_tables.py
```

**验证表是否创建成功**：

**Oracle**：
```sql
-- 连接到Oracle
sqlplus asset_user/password@host:port/service_name

-- 查看所有表
SELECT table_name FROM user_tables ORDER BY table_name;

-- 应该看到：users, assets, asset_categories, transfer_requests 等表
```

**SQL Server**：
```sql
-- 连接到SQL Server
USE asset_management;
GO

-- 查看所有表
SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';
GO

-- 应该看到：users, assets, asset_categories, transfer_requests 等表
```

### 4.2 数据迁移脚本

#### 步骤4.2.1：创建数据迁移脚本

创建 `backend/migrate_data.py`：

```python
"""
数据迁移脚本
从SQLite迁移到Oracle/SQL Server
"""
import os
from dotenv import load_dotenv
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from pathlib import Path

# 加载环境变量
load_dotenv()

print("=" * 50)
print("数据迁移工具")
print("=" * 50)

# 源数据库（SQLite）
BASE_DIR = Path(__file__).resolve().parent
SQLITE_DB_PATH = BASE_DIR / "assets.db"

if not SQLITE_DB_PATH.exists():
    print(f"❌ SQLite数据库文件不存在: {SQLITE_DB_PATH}")
    exit(1)

sqlite_url = f"sqlite:///{SQLITE_DB_PATH}"
print(f"源数据库: {sqlite_url}")

# 目标数据库（从环境变量读取）
DB_TYPE = os.getenv("DB_TYPE", "sqlite")
if DB_TYPE == "sqlite":
    print("❌ 错误：目标数据库不能是SQLite")
    print("请设置DB_TYPE环境变量为oracle或sqlserver")
    exit(1)

print(f"目标数据库: {DB_TYPE.upper()}")

# 创建数据库引擎
sqlite_engine = create_engine(sqlite_url)
target_engine = None

try:
    from database import engine as target_engine_from_config
    target_engine = target_engine_from_config
except Exception as e:
    print(f"❌ 无法创建目标数据库连接: {e}")
    exit(1)

# 创建会话
SqliteSession = sessionmaker(bind=sqlite_engine)
TargetSession = sessionmaker(bind=target_engine)

sqlite_session = SqliteSession()
target_session = TargetSession()

# 导入所有模型
from models import (
    User, AssetCategory, Asset, TransferRequest, ReturnRequest,
    AssetEditRequest, AssetHistory, SafetyCheckType, SafetyCheckTask,
    TaskAsset, SafetyCheckHistory
)

def migrate_table(model_class, table_name):
    """迁移单个表的数据"""
    try:
        print(f"\n迁移表: {table_name}...")
        
        # 从SQLite读取数据
        source_data = sqlite_session.query(model_class).all()
        print(f"  源数据库记录数: {len(source_data)}")
        
        if len(source_data) == 0:
            print(f"  ⚠️  表 {table_name} 无数据，跳过")
            return 0
        
        # 迁移数据
        success_count = 0
        error_count = 0
        
        for item in source_data:
            try:
                # 使用merge避免主键冲突
                target_session.merge(item)
                success_count += 1
            except Exception as e:
                error_count += 1
                print(f"  ⚠️  记录迁移失败: {e}")
                # 继续迁移其他记录
        
        # 提交事务
        target_session.commit()
        print(f"  ✅ 成功: {success_count} 条，失败: {error_count} 条")
        return success_count
        
    except Exception as e:
        print(f"  ❌ 迁移失败: {e}")
        target_session.rollback()
        import traceback
        traceback.print_exc()
        return 0

# 按依赖顺序迁移表
print("\n开始数据迁移...")
print("=" * 50)

# 迁移顺序（考虑外键依赖）
migration_order = [
    (User, "users"),
    (AssetCategory, "asset_categories"),
    (Asset, "assets"),
    (SafetyCheckType, "safety_check_types"),
    (SafetyCheckTask, "safety_check_tasks"),
    (TransferRequest, "transfer_requests"),
    (ReturnRequest, "return_requests"),
    (AssetEditRequest, "asset_edit_requests"),
    (TaskAsset, "task_assets"),
    (AssetHistory, "asset_history"),
    (SafetyCheckHistory, "safety_check_history"),
]

total_migrated = 0
for model_class, table_name in migration_order:
    count = migrate_table(model_class, table_name)
    total_migrated += count

print("\n" + "=" * 50)
print(f"数据迁移完成！")
print(f"总计迁移记录数: {total_migrated}")
print("=" * 50)

# 验证数据
print("\n验证数据...")
for model_class, table_name in migration_order:
    source_count = sqlite_session.query(model_class).count()
    target_count = target_session.query(model_class).count()
    status = "✅" if source_count == target_count else "⚠️"
    print(f"{status} {table_name}: 源={source_count}, 目标={target_count}")

# 关闭会话
sqlite_session.close()
target_session.close()

print("\n迁移完成！")
```

#### 步骤4.2.2：执行数据迁移

**步骤4.2.2.1：备份SQLite数据库（再次确认）**

```bash
# 确保已备份
cp assets.db assets_migration_backup.db
```

**步骤4.2.2.2：配置目标数据库环境变量**

```bash
# 设置.env文件或环境变量
# 确保DB_TYPE指向目标数据库
```

**步骤4.2.2.3：运行迁移脚本**

```bash
python migrate_data.py
```

**预期输出**：
```
==================================================
数据迁移工具
==================================================
源数据库: sqlite:///C:/path/to/assets.db
目标数据库: ORACLE

开始数据迁移...
==================================================

迁移表: users...
  源数据库记录数: 10
  ✅ 成功: 10 条，失败: 0 条

迁移表: asset_categories...
  源数据库记录数: 5
  ✅ 成功: 5 条，失败: 0 条

...

==================================================
数据迁移完成！
总计迁移记录数: 150
==================================================
```

#### 步骤4.2.3：验证数据完整性

创建 `backend/verify_migration.py`：

```python
"""
验证数据迁移完整性
"""
import os
from dotenv import load_dotenv
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from pathlib import Path

load_dotenv()

# 源数据库
BASE_DIR = Path(__file__).resolve().parent
sqlite_url = f"sqlite:///{BASE_DIR / 'assets.db'}"
sqlite_engine = create_engine(sqlite_url)
SqliteSession = sessionmaker(bind=sqlite_engine)

# 目标数据库
from database import engine as target_engine
TargetSession = sessionmaker(bind=target_engine)

sqlite_session = SqliteSession()
target_session = TargetSession()

from models import (
    User, AssetCategory, Asset, TransferRequest, ReturnRequest,
    AssetEditRequest, AssetHistory, SafetyCheckType, SafetyCheckTask,
    TaskAsset, SafetyCheckHistory
)

tables = [
    (User, "users"),
    (AssetCategory, "asset_categories"),
    (Asset, "assets"),
    (SafetyCheckType, "safety_check_types"),
    (SafetyCheckTask, "safety_check_tasks"),
    (TransferRequest, "transfer_requests"),
    (ReturnRequest, "return_requests"),
    (AssetEditRequest, "asset_edit_requests"),
    (TaskAsset, "task_assets"),
    (AssetHistory, "asset_history"),
    (SafetyCheckHistory, "safety_check_history"),
]

print("=" * 50)
print("数据完整性验证")
print("=" * 50)

all_match = True
for model_class, table_name in tables:
    source_count = sqlite_session.query(model_class).count()
    target_count = target_session.query(model_class).count()
    
    status = "✅" if source_count == target_count else "❌"
    if source_count != target_count:
        all_match = False
    
    print(f"{status} {table_name:30s} 源: {source_count:5d}  目标: {target_count:5d}")

print("=" * 50)
if all_match:
    print("✅ 所有表数据数量匹配！")
else:
    print("❌ 部分表数据数量不匹配，请检查迁移日志")

sqlite_session.close()
target_session.close()
```

运行验证：
```bash
python verify_migration.py
```

---

## 步骤五：测试验证

### 5.1 连接测试

**步骤5.1.1：运行连接测试**

```bash
python test_connection.py
```

**预期结果**：显示连接成功

### 5.2 功能测试

#### 步骤5.2.1：启动后端服务

```bash
# 确保.env文件配置正确
cd backend
python -m uvicorn main:app --reload --port 8000
```

**检查点**：
- [ ] 服务正常启动，无错误
- [ ] 可以访问 http://localhost:8000/docs

#### 步骤5.2.2：功能测试清单

创建测试脚本 `backend/test_functionality.py`：

```python
"""
功能测试脚本
"""
import requests
import json

BASE_URL = "http://localhost:8000/api"

# 1. 测试登录
print("1. 测试登录...")
login_data = {
    "ehr_number": "0000001",
    "password": "admin123"
}
response = requests.post(f"{BASE_URL}/auth/login", json=login_data)
if response.status_code == 200:
    token = response.json()["access_token"]
    headers = {"Authorization": f"Bearer {token}"}
    print("✅ 登录成功")
else:
    print(f"❌ 登录失败: {response.text}")
    exit(1)

# 2. 测试获取用户列表
print("\n2. 测试获取用户列表...")
response = requests.get(f"{BASE_URL}/users/", headers=headers)
if response.status_code == 200:
    users = response.json()
    print(f"✅ 获取用户列表成功，共 {len(users)} 个用户")
else:
    print(f"❌ 获取用户列表失败: {response.text}")

# 3. 测试获取资产列表
print("\n3. 测试获取资产列表...")
response = requests.get(f"{BASE_URL}/assets/", headers=headers)
if response.status_code == 200:
    assets = response.json()
    print(f"✅ 获取资产列表成功，共 {len(assets)} 个资产")
else:
    print(f"❌ 获取资产列表失败: {response.text}")

# 4. 测试创建资产
print("\n4. 测试创建资产...")
asset_data = {
    "asset_number": "TEST001",
    "category_id": 1,
    "name": "测试资产",
    "status": "在用"
}
response = requests.post(f"{BASE_URL}/assets/", json=asset_data, headers=headers)
if response.status_code == 200:
    print("✅ 创建资产成功")
    # 删除测试资产
    asset_id = response.json()["id"]
    requests.delete(f"{BASE_URL}/assets/{asset_id}", headers=headers)
else:
    print(f"❌ 创建资产失败: {response.text}")

print("\n" + "=" * 50)
print("功能测试完成")
print("=" * 50)
```

**运行测试**：
```bash
pip install requests  # 如果还没安装
python test_functionality.py
```

#### 步骤5.2.3：手动测试清单

在浏览器中手动测试以下功能：

- [ ] **用户登录**
  - 访问 http://localhost:3000
  - 使用管理员账户登录（EHR: 0000001, 密码: admin123）
  - 验证登录成功

- [ ] **用户管理**
  - 查看用户列表
  - 创建新用户
  - 编辑用户
  - 删除用户

- [ ] **资产管理**
  - 查看资产列表
  - 创建新资产
  - 编辑资产
  - 删除资产
  - 查看资产历史记录

- [ ] **资产交接**
  - 创建交接申请
  - 查看申请列表
  - 审批申请

- [ ] **资产退回**
  - 创建退回申请
  - 查看申请列表
  - 审批申请

- [ ] **资产编辑申请**
  - 创建编辑申请
  - 查看申请状态
  - 审批申请

- [ ] **安全检查任务**
  - 创建检查类型
  - 发布检查任务
  - 查看任务列表
  - 提交检查结果

- [ ] **批量导入**
  - 导入用户
  - 导入资产
  - 查看导入错误详情

### 5.3 性能测试

#### 步骤5.3.1：查询性能测试

创建 `backend/test_performance.py`：

```python
"""
性能测试
"""
import time
from database import SessionLocal
from models import Asset

db = SessionLocal()

# 测试查询性能
print("测试查询性能...")

# 测试1：简单查询
start = time.time()
assets = db.query(Asset).limit(100).all()
elapsed = time.time() - start
print(f"查询100条资产: {elapsed:.3f}秒")

# 测试2：带条件查询
start = time.time()
assets = db.query(Asset).filter(Asset.status == "在用").limit(100).all()
elapsed = time.time() - start
print(f"条件查询100条资产: {elapsed:.3f}秒")

# 测试3：关联查询
start = time.time()
assets = db.query(Asset).join(Asset.user).limit(100).all()
elapsed = time.time() - start
print(f"关联查询100条资产: {elapsed:.3f}秒")

db.close()
```

#### 步骤5.3.2：并发测试

使用工具如Apache Bench (ab) 或 wrk：

```bash
# 安装ab（Apache Bench）
# Windows: 通常已包含在Apache中
# Linux: sudo apt-get install apache2-utils

# 测试API性能
ab -n 100 -c 10 http://localhost:8000/api/users/
```

### 5.4 数据完整性验证

#### 步骤5.4.1：验证外键关系

创建 `backend/verify_integrity.py`：

```python
"""
验证数据完整性
"""
from database import SessionLocal
from models import Asset, User, AssetCategory

db = SessionLocal()

# 检查孤立记录
print("检查数据完整性...")

# 检查资产是否有无效的category_id
invalid_categories = db.query(Asset).filter(
    ~Asset.category_id.in_(db.query(AssetCategory.id))
).count()
print(f"无效的category_id: {invalid_categories}")

# 检查资产是否有无效的user_id（user_id可以为空，所以只检查非空的）
invalid_users = db.query(Asset).filter(
    Asset.user_id.isnot(None),
    ~Asset.user_id.in_(db.query(User.id))
).count()
print(f"无效的user_id: {invalid_users}")

db.close()
```

---

## 步骤六：上线部署

### 6.1 生产环境配置

#### 步骤6.1.1：创建生产环境.env文件

在生产服务器上创建 `backend/.env.production`：

```env
# 生产环境配置
DB_TYPE=oracle
DB_USER=asset_user
DB_PASSWORD=生产环境密码
DB_HOST=生产数据库IP
DB_PORT=1521
DB_SERVICE_NAME=ORCL

# 连接池配置（生产环境可以增大）
DB_POOL_SIZE=10
DB_MAX_OVERFLOW=20
```

#### 步骤6.1.2：安全配置

- [ ] 使用强密码
- [ ] 限制数据库访问IP
- [ ] 启用SSL/TLS连接（如果可能）
- [ ] 配置防火墙规则
- [ ] 定期备份数据库

### 6.2 部署检查清单

- [ ] 数据库连接配置正确
- [ ] 所有表结构已创建
- [ ] 数据已迁移完成
- [ ] 功能测试通过
- [ ] 性能测试通过
- [ ] 备份方案已准备
- [ ] 回滚方案已准备
- [ ] 监控和日志已配置

### 6.3 上线步骤

1. **停止旧服务**（如果正在运行）
2. **备份旧数据库**（SQLite）
3. **配置新数据库连接**
4. **启动新服务**
5. **验证服务正常**
6. **通知用户**

---

## 常见问题排查

### 问题1：连接失败

**症状**：`无法连接到数据库`

**排查步骤**：

1. **检查网络连接**
   ```bash
   # 测试网络连通性
   ping 数据库服务器IP
   
   # 测试端口
   telnet 数据库服务器IP 端口
   # 或使用
   nc -zv 数据库服务器IP 端口
   ```

2. **检查防火墙**
   - 确保防火墙允许数据库端口
   - 检查安全组规则（云服务器）

3. **检查数据库服务**
   - Oracle：检查监听器是否启动
   - SQL Server：检查SQL Server服务是否运行

4. **检查连接字符串**
   - 验证用户名、密码
   - 验证主机、端口
   - 验证Service Name/SID（Oracle）

### 问题2：字符编码问题

**症状**：中文显示乱码

**解决方案**：

**Oracle**：
```sql
-- 检查字符集
SELECT * FROM NLS_DATABASE_PARAMETERS WHERE PARAMETER LIKE '%CHARACTERSET%';

-- 应该显示 AL32UTF8
-- 如果不是，需要联系DBA修改数据库字符集
```

**SQL Server**：
```sql
-- 检查排序规则
SELECT DATABASEPROPERTYEX('asset_management', 'Collation');

-- 应该包含 Chinese_PRC 或 SQL_Latin1
-- 创建数据库时使用：COLLATE Chinese_PRC_CI_AS
```

### 问题3：自增ID问题

**症状**：插入数据时ID冲突

**解决方案**：
- SQLAlchemy会自动处理，但需要确保模型定义正确
- Oracle：检查SEQUENCE是否创建
- SQL Server：检查IDENTITY是否启用

### 问题4：性能问题

**症状**：查询速度慢

**解决方案**：

1. **添加索引**
   ```sql
   -- Oracle
   CREATE INDEX idx_asset_user_id ON assets(user_id);
   CREATE INDEX idx_asset_status ON assets(status);
   
   -- SQL Server
   CREATE INDEX idx_asset_user_id ON assets(user_id);
   CREATE INDEX idx_asset_status ON assets(status);
   ```

2. **优化连接池**
   - 增加pool_size
   - 调整max_overflow

3. **分析慢查询**
   - 启用SQL日志（echo=True）
   - 使用数据库性能分析工具

### 问题5：事务问题

**症状**：数据不一致

**解决方案**：
- 确保使用事务（db.commit()）
- 检查异常处理中的rollback
- 使用数据库事务日志

---

## 迁移后维护

### 1. 定期备份

**Oracle**：
```bash
# 使用expdp导出
expdp asset_user/password@service_name directory=backup_dir dumpfile=backup_$(date +%Y%m%d).dmp
```

**SQL Server**：
```sql
BACKUP DATABASE asset_management TO DISK = 'C:\backup\asset_management_$(date +%Y%m%d).bak'
```

### 2. 监控

- 监控数据库连接数
- 监控查询性能
- 监控磁盘空间
- 监控错误日志

### 3. 优化

- 定期分析慢查询
- 优化索引
- 清理历史数据（如果需要）

---

## 总结

通过以上步骤，可以完成从SQLite到Oracle/SQL Server的迁移。关键点：

1. **配置化**：通过环境变量实现零代码修改
2. **测试**：充分测试确保功能正常
3. **备份**：始终保留备份
4. **验证**：验证数据完整性
5. **监控**：上线后持续监控

如有问题，请参考各数据库的官方文档或联系数据库管理员。
